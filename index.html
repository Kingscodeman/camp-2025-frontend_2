<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PARKGO</title>
    <link rel="stylesheet" href="./main.css">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap" rel="stylesheet">
    <style>
    /* i-modal.html modal styles */
    #open-modal {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #00ccff;
      color: #000;
      border: none;
      padding: 10px 16px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      z-index: 1001;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      overflow: auto;
      background-color: rgba(0,0,0,0.8);
    }
    .modal-content {
      background-color: #1c1c1e;
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      width: 90%;
      max-width: 800px;
      color: #fff;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    .close {
      color: #aaa;
      float: right;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
    }
    .highlight {
      color: #00ccff;
      font-weight: bold;
    }
    .modal-content a {
      color: #00ccff;
      text-decoration: none;
    }
    .modal-content a:hover {
      text-decoration: underline;
    }
    #main-title {
      font-family: 'Montserrat', 'Segoe UI', 'Arial', sans-serif;
      font-size: 2.1rem;
      letter-spacing: 2px;
      font-weight: 700;
      color: #fff;
      margin-left: 48px;
      position: relative;
      top: -1px;
    }

    /* æ–°å¢ï¼šæŒ‰éˆ•æ¨£å¼ */
    #range-submit-btn {
      display: block;
      width: 60%;
      margin: 16px 0 0 12%;
      padding: 10px 0;
      border: none;
      border-radius: 24px;
      background: linear-gradient(90deg, #3498db 0%, #6dd5fa 100%);
      color: #fff;
      font-size: 1.1rem;
      font-weight: bold;
      box-shadow: 0 2px 8px rgba(52,152,219,0.15);
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s, transform 0.1s;
      letter-spacing: 2px;
      text-align: center;
      outline: none;
    }
    #range-submit-btn:hover, #range-submit-btn:focus {
      background: linear-gradient(90deg, #217dbb 0%, #43c6f7 100%);
      box-shadow: 0 4px 16px rgba(52,152,219,0.25);
      transform: translateY(-2px) scale(1.04);
    }
    </style>
</head>
<body>
    <!-- å®šä½æ¬Šé™è«‹æ±‚é®ç½©å±¤ (é è¨­éš±è—) -->
    <div id="location-overlay">
        <div class="overlay-content">
            <h2>éœ€è¦æ‚¨çš„ä½ç½®æ¬Šé™</h2>
            <p>ç‚ºäº†æä¾›åœè»Šå ´è³‡è¨Šï¼Œæœ¬ç¶²ç«™éœ€è¦å–å¾—æ‚¨ç›®å‰çš„ä½ç½®ã€‚è«‹å…è¨±æˆ‘å€‘å­˜å–æ‚¨çš„ä½ç½®è³‡è¨Šã€‚</p>
            <button id="retry-location-btn">é‡è©¦</button>
        </div>
    </div>

    <!-- å·¦å´æ»‘å‹•ç¯©é¸æ¬„ -->
    <div id="filter-sidenav" class="sidenav" style="position: fixed; top: 56px; left: 0; width: 320px; height: calc(100vh - 56px); z-index: 200; background: #222; transition: left 0.3s; overflow-y: auto;">
        <div class="condition-toggle-group">
            <label id="condition-toggle-label" style="cursor:pointer;">ç¯©é¸æ¢ä»¶</label>
            <button id="condition-toggle-btn" class="triangle-btn" type="button" aria-label="å±•é–‹æ¢ä»¶"></button>
        </div>
        <div id="condition-checkbox-group">
            <div class="checkbox-row">
                <label><input type="checkbox"> å®¤å…§åœè»Šå ´</label>
                <label><input type="checkbox"> é›»å‹•è»Šå……é›»</label>
            </div>
            <input type="text" id="price-input" placeholder="åƒ¹æ ¼ä¸Šé™(å…ƒ/h)ï¼Œä¾‹å¦‚: 50">
        </div>
        <div class="range-toggle-group">
            <label for="range-select" id="range-toggle-label" style="cursor:pointer;">æœå°‹ç¯„åœ</label>
            <button id="range-toggle-btn" class="triangle-btn" type="button" aria-label="å±•é–‹æœå°‹ç¯„åœ"></button>
        </div>

        <div id="range-select-group" style="display: block;">
            <select id="range-select" onchange="updateRangePlaceholder()">
                <option value="count">æœ€è¿‘çš„____å€‹</option>
                <option value="distance">____å…¬å°ºä»¥å…§</option>
            </select>
            <input type="text" id="range-input" placeholder="10">
            <!-- æ’åºå€å¡Šï¼šä¸‰è¡Œè·é›¢/åƒ¹æ ¼/å‰©é¤˜ç©ºä½ï¼Œæ¯è¡Œå³å´æœ‰ä¸Šä¸‹ç®­é ­ -->
            <div class="sort-list-group" style="width: calc(100% - 72px); margin-left: 0; margin-top: 12px; margin-bottom: 8px; display: flex; flex-direction: column; gap: 4px;">
                <div class="sort-row sort-second"><span class="sort-label">ğŸ“è·é›¢</span><span></span></div>
                <div class="sort-row sort-second"><span class="sort-label">ğŸ’²åƒ¹æ ¼</span><span></span></div>
                <div class="sort-row sort-second"><span class="sort-label">ğŸ…¿ï¸å‰©é¤˜ç©ºä½</span><span></span></div>
            </div>
            <button id="range-submit-btn" style="margin-left:8px; padding:2px 10px; border-radius:4px; border:1px solid #888; background:#444; color:#fff; cursor:pointer; margin-top: 8px;">å¥—ç”¨</button>
        </div>
        <script>
        function updateRangePlaceholder() {
            var select = document.getElementById('range-select');
            var input = document.getElementById('range-input');
            if (select.value === 'count') {
                input.placeholder = 'ä¾‹å¦‚ï¼š10';
            } else {
                input.placeholder = 'ä¾‹å¦‚ï¼š500';
            }
        }
        // å±•é–‹/æ”¶åˆæœå°‹ç¯„åœ
        document.addEventListener('DOMContentLoaded', function() {
            var btn = document.getElementById('range-toggle-btn');
            var group = document.getElementById('range-select-group');
            var label = document.getElementById('range-toggle-label');
            function toggleRange() {
                if (group.style.display === 'none') {
                    group.style.display = 'block';
                    btn.classList.add('open');
                } else {
                    group.style.display = 'none';
                    btn.classList.remove('open');
                }
            }
            btn.addEventListener('click', toggleRange);
            label.addEventListener('click', toggleRange);
            // æ¢ä»¶å±•é–‹/æ”¶åˆ
            var condBtn = document.getElementById('condition-toggle-btn');
            var condLabel = document.getElementById('condition-toggle-label');
            var condGroup = document.getElementById('condition-checkbox-group');
            function toggleCond() {
                if (condGroup.style.display === 'none' || condGroup.style.display === '') {
                    condGroup.style.display = 'block';
                    condBtn.classList.add('open');
                } else {
                    condGroup.style.display = 'none';
                    condBtn.classList.remove('open');
                }
            }
            condBtn.addEventListener('click', toggleCond);
            condLabel.addEventListener('click', toggleCond);

            // å‹•æ…‹æ¸²æŸ“æ’åºç®­é ­
            function renderSortArrows() {
                const sortList = document.querySelector('.sort-list-group');
                const rows = Array.from(sortList.querySelectorAll('.sort-row'));
                rows.forEach((row, idx) => {
                    const label = row.querySelector('.sort-label').textContent.trim();
                    const span = row.querySelector('span:last-child');
                    span.innerHTML = '';
                    // ä¸Šç®­é ­
                    if (idx > 0) {
                        const upBtn = document.createElement('button');
                        upBtn.className = 'sort-arrow sort-up';
                        upBtn.title = label + 'ä¸Šç§»';
                        upBtn.style = 'background:none; border:none; cursor:pointer; padding:2px 4px;';
                        upBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16"><path d="M8 4l4 6H4z" fill="#818181"/></svg>';
                        upBtn.addEventListener('click', function(e) {
                            e.preventDefault();
                            const prev = row.previousElementSibling;
                            if (prev && prev.classList.contains('sort-row')) {
                                sortList.insertBefore(row, prev);
                                renderSortArrows();
                            }
                        });
                        span.appendChild(upBtn);
                    }
                    // ä¸‹ç®­é ­
                    if (idx < rows.length - 1) {
                        const downBtn = document.createElement('button');
                        downBtn.className = 'sort-arrow sort-down';
                        downBtn.title = label + 'ä¸‹ç§»';
                        downBtn.style = 'background:none; border:none; cursor:pointer; padding:2px 4px;';
                        downBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16"><path d="M8 12l-4-6h8z" fill="#818181"/></svg>';
                        downBtn.addEventListener('click', function(e) {
                            e.preventDefault();
                            const next = row.nextElementSibling;
                            if (next && next.classList.contains('sort-row')) {
                                sortList.insertBefore(next, row);
                                renderSortArrows();
                            }
                        });
                        span.appendChild(downBtn);
                    }
                });
            }
            renderSortArrows();
        });
        </script>
        <!-- æ‰¾åˆ°çš„åœè»Šå ´å€å¡Šï¼Œç›´æ¥è·Ÿåœ¨ input ä¸‹æ–¹ -->
        <div id="parking-info-block">
            <h3 style="text-align:center; font-size:20px; color:#fff; margin-bottom:8px;">æ‰¾åˆ°çš„åœè»Šå ´</h3>
            <div id="info-content">
                <ul id="parking-list" style="background:rgba(255,255,255,0.95); color:#222; border-radius:8px; margin:0 16px; padding:8px 0;"></ul>
            </div>
        </div>
    </div>

    <!-- é ‚éƒ¨æ¨™é¡Œæ¬„ï¼ŒåŒ…å«æŒ‰éˆ•å’Œç¶²ç«™æ¨™é¡Œ -->
    <div id="top-bar" style="position: fixed; top: 0; left: 0; width: 100%; z-index: 100; height: 56px; background: #222; display: flex; align-items: center;">
        <button id="menu-toggle-btn" style="position:absolute; left:16px; top:50%; transform:translateY(-50%); z-index:20; background:#333; color:#fff; border:none; border-radius:4px; padding:8px 12px; font-size:20px; cursor:pointer;">â˜°</button>
        <h1 id="main-title">PARKGO</h1>
    </div>

    <!-- åœ°åœ–å…¨è¢å¹•å€åŸŸ -->
    <div id="map-container" style="position: absolute; top: 56px; left: 0; width: 100vw; height: calc(100vh - 56px);">
        <div id="map" style="width: 100vw; height: 100%; min-height: 400px;"></div>
        <button id="locate-btn" class="locate-btn" onclick="locateUser()" title="å®šä½æˆ‘" style="position: absolute; right: 24px; bottom: 24px; z-index: 300;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="12" cy="12" r="8" stroke="#3498db" stroke-width="2" fill="#fff"/>
              <circle cx="12" cy="12" r="3" fill="#3498db"/>
            </svg>
        </button>
        <!-- æ–°å¢ï¼šåœ°åœ–ç¸®æ”¾é¡¯ç¤º -->
        <div id="zoom-level-display" style="position: absolute; right: 24px; bottom: 80px; z-index: 301; background: rgba(0,0,0,0.7); color: #fff; padding: 6px 14px; border-radius: 6px; font-size: 15px;">
      Zoom: 13.00
    </div>
    </div>

    <!-- å¼•å…¥ JavaScript æª”æ¡ˆ -->
    <script src="./main.js"></script>
    <script>
  mapboxgl.accessToken = 'pk.eyJ1IjoiY2FzcGVyMjEiLCJhIjoiY21jemluNnduMHQ5NTJrc2J6dGNoeG4zNCJ9.YOJYDPzvov3Q_SsxqjyR-A';

  // å˜—è©¦åœ¨é é¢è¼‰å…¥æ™‚è‡ªå‹•å®šä½
  document.addEventListener('DOMContentLoaded', function() {
    locateUser();
  });

  let userLocation = null;
  let currentRouteId = null;
  let activePopup = null;
  let parking_list = [];  // å„²å­˜è·é›¢è³‡æ–™
  let parking_markers = [];  // å„²å­˜ marker å’Œåœè»Šå ´è³‡æ–™å°æ‡‰
  let filterIndoor = false; // Variable to store whether 'å®¤å…§åœè»Šå ´' is selected
let filterEV = false; // Variable to store whether 'é›»å‹•è»Šå……é›»' is selected
let MAX_PARKING_RENDER = 10; // Default value, now let
let priceUpperLimit = null; // åƒ¹æ ¼ä¸Šé™
let rangeMode = 'count'; // 'count' or 'distance'
let rangeValue = null; // æ•¸å€¼ (å€‹æ•¸æˆ–å…¬å°º)

  // åœ°åœ–åˆå§‹åŒ–
  const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/dark-v11',
    center: [121.5376, 25.0273],
    zoom: 13
  });




  // ====== å‹•æ…‹æ’åºå„ªå…ˆé †åº ======
  let currentSortPriority = getSortPriorityFromDOM();

  function getSortPriorityFromDOM() {
    const sortLabels = document.querySelectorAll('.sort-list-group .sort-label');
    return Array.from(sortLabels).map(label => {
      const text = label.textContent.trim();
      if (text.includes('è·é›¢')) return 'distance';
      if (text.includes('åƒ¹æ ¼')) return 'price';
      if (text.includes('å‰©é¤˜ç©ºä½')) return 'spaces';
      return null;
    }).filter(Boolean);
  }

  // ç›£è½æ’åºé †åºè®Šå‹•ï¼Œæ›´æ–° currentSortPriority
  document.addEventListener('DOMContentLoaded', function() {
    const sortList = document.querySelector('.sort-list-group');
    if (sortList) {
      sortList.addEventListener('click', function(e) {
        if (e.target.closest('.sort-arrow')) {
          currentSortPriority = getSortPriorityFromDOM();
        }
      });
    }
  });

  function sortParkingLots(lots) {
    // ä½¿ç”¨ currentSortPriority é€²è¡Œæ’åº
    return lots.slice().sort((a, b) => {
      for (let key of currentSortPriority) {
        let aVal, bVal;
        if (key === 'distance') {
          aVal = a.distance ?? Infinity;
          bVal = b.distance ?? Infinity;
        } else if (key === 'price') {
          const parsePrice = v => {
            if (typeof v.price === 'number') return v.price;
            if (typeof v.price === 'string') {
              const match = v.price.match(/(\d+)[å…ƒ|\/]/);
              return match ? parseInt(match[1], 10) : Infinity;
            }
            return Infinity;
          };
          aVal = parsePrice(a);
          bVal = parsePrice(b);
        } else if (key === 'spaces') {
          aVal = (a.totalcar ?? 0) - (a.usedcar ?? 0);
          bVal = (b.totalcar ?? 0) - (b.usedcar ?? 0);
          // ç©ºä½å¤šçš„æ’å‰é¢
          if (aVal !== bVal) return bVal - aVal;
          continue;
        }
        if (aVal !== bVal) return aVal - bVal;
      }
      return 0;
    });
  }

  // Compute distance between two coordinates (Haversine formula)
  function computeDistance(lat1, lng1, lat2, lng2) {
    const R = 6371; // Earth radius in km
    const toRad = deg => deg * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLng = toRad(lng2 - lng1);
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLng / 2) * Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  // Get user location first, then fetch and process parking lots
  function renderParkingLotsWithDistance(userLat, userLng) {
    // Remove all existing markers from the map
    parking_markers.forEach(item => item.marker.remove());
    parking_markers = [];
    fetch('data/TCMSV_alldesc.json')
      .then(response => response.json())
      .then(json => {
        let allParkingLots = json.data.park.slice(); // Store all parking lots
        // Precompute distance for each lot (before filtering)
        allParkingLots.forEach(lot => {
          lot.distance = computeDistance(userLat, userLng, lot.lat, lot.lng);
        });
        allParkingLots = sortParkingLots(allParkingLots); // æŒ‰å„ªå…ˆé †åºæ’åº
        // Apply filters
        let filteredLots = [];
        let i = 0;
        if (rangeMode === 'distance' && rangeValue !== null && !isNaN(rangeValue)) {
          // åƒ…é¡¯ç¤ºè·é›¢åœ¨ rangeValue å…¬å°ºä»¥å…§çš„
          while (i < allParkingLots.length) {
            const lot = allParkingLots[i];
            // å–å¾—åƒ¹æ ¼æ•¸å€¼
            let lotPrice = null;
            if (typeof lot.price === 'number') {
              lotPrice = lot.price;
            } else if (typeof lot.price === 'string') {
              const match = lot.price.match(/(\d+)/);
              lotPrice = match ? parseInt(match[1], 10) : null;
            }
            // æª¢æŸ¥åƒ¹æ ¼ä¸Šé™
            let priceOk = true;
            if (priceUpperLimit !== null && !isNaN(priceUpperLimit)) {
              priceOk = (lotPrice !== null && lotPrice <= priceUpperLimit);
            }
            // æª¢æŸ¥è·é›¢
            let distOk = (lot.distance * 1000 <= rangeValue);
            if ((!filterIndoor || lot.inside === true) && (!filterEV || lot.charge === true) && priceOk && distOk) {
              filteredLots.push(lot);
            }
            i++;
          }
        } else {
          // é è¨­ï¼šæœ€è¿‘çš„ MAX_PARKING_RENDER å€‹
          while (filteredLots.length < MAX_PARKING_RENDER && i < allParkingLots.length) {
            const lot = allParkingLots[i];
            // å–å¾—åƒ¹æ ¼æ•¸å€¼
            let lotPrice = null;
            if (typeof lot.price === 'number') {
              lotPrice = lot.price;
            } else if (typeof lot.price === 'string') {
              const match = lot.price.match(/(\d+)/);
              lotPrice = match ? parseInt(match[1], 10) : null;
            }
            // æª¢æŸ¥åƒ¹æ ¼ä¸Šé™
            let priceOk = true;
            if (priceUpperLimit !== null && !isNaN(priceUpperLimit)) {
              priceOk = (lotPrice !== null && lotPrice <= priceUpperLimit);
            }
            if ((!filterIndoor || lot.inside === true) && (!filterEV || lot.charge === true) && priceOk) {
              filteredLots.push(lot);
            }
            i++;
          }
        }
        filteredLots.forEach(point => {
          // è¨ˆç®—å‰©é¤˜ç©ºä½
          const spaces = (typeof point.totalcar === 'number') ? point.totalcar : (point.totalcar ? point.totalcar : 'æœªçŸ¥');
          const popupContent = `${point.name}ï½œåƒ¹æ ¼ï¼š${point.price}ï½œå‰©é¤˜ç©ºä½ï¼š${spaces}`;
          const marker = new mapboxgl.Marker({ color: '#e74c3c' })
            .setLngLat([point.lng, point.lat])
            .setPopup(new mapboxgl.Popup().setText(popupContent))
            .addTo(map);

          // æŠŠ marker å’Œå°æ‡‰åœè»Šå ´è³‡æ–™æ”¾é€²é™£åˆ—
          parking_markers.push({ marker: marker, data: point });

          // hover äº‹ä»¶ï¼ˆå…ˆåªé¡¯ç¤º popupï¼Œä¸ç•«è·¯ç·šï¼‰
          marker.getElement().addEventListener('mouseenter', () => {
            const parkingInfo = parking_list.find(p => p.name === point.name);
            if (parkingInfo && userLocation) {
              // å¦‚æœå·²è¨ˆç®—éè·é›¢ï¼Œå°±ç•«è·¯ç·šå’Œé¡¯ç¤º popup
              if (currentRouteId) {
                if (map.getSource(currentRouteId)) {
                  map.removeLayer(currentRouteId);
                  map.removeSource(currentRouteId);
                }
              }
              if (activePopup) activePopup.remove();

              currentRouteId = 'route-' + Date.now();
              map.addSource(currentRouteId, {
                type: 'geojson',
                data: { type: 'Feature', geometry: parkingInfo.route }
              });
              map.addLayer({
                id: currentRouteId,
                type: 'line',
                source: currentRouteId,
                layout: { 'line-cap': 'round', 'line-join': 'round' },
                paint: { 'line-color': '#3b9ddd', 'line-width': 4 }
              });

              const coords = parkingInfo.route.coordinates;
              const midPoint = coords[Math.floor(coords.length / 2)];

              activePopup = new mapboxgl.Popup({ closeButton: false, closeOnClick: false })
                .setLngLat(midPoint)
                .setHTML(`<strong>è·é›¢:</strong> ${parkingInfo.distance} km<br><strong>é ä¼°:</strong> ${parkingInfo.duration} åˆ†`)
                .addTo(map);
            }
          });

          marker.getElement().addEventListener('mouseleave', () => {
            if (currentRouteId) {
              if (map.getSource(currentRouteId)) {
                map.removeLayer(currentRouteId);
                map.removeSource(currentRouteId);
              }
              currentRouteId = null;
            }
            if (activePopup) {
              activePopup.remove();
              activePopup = null;
            }
          });
        });

        // Add this function to update the parking list
        function updateParkingList(lots) {
          const list = document.getElementById('parking-list');
          list.innerHTML = '';
          lots.forEach(lot => {
            const li = document.createElement('li');
            // é¡¯ç¤ºåç¨±ã€è·é›¢ã€åƒ¹æ ¼ã€å‰©é¤˜ç©ºä½
            const price = (typeof lot.price === 'number') ? lot.price : (lot.price ? lot.price : 'æœªçŸ¥');
            const spaces = (typeof lot.totalcar === 'number') ? lot.totalcar : (lot.totalcar ? lot.totalcar : 'æœªçŸ¥');
            li.innerHTML = `<strong>${lot.name}</strong><br>
              è·é›¢ï¼š${Math.round(lot.distance * 1000)} å…¬å°º<br>
              åƒ¹æ ¼ï¼š${price} å…ƒ/æ™‚<br>
              å‰©é¤˜ç©ºä½ï¼š${spaces} æ ¼`;
            list.appendChild(li);
          });
        }

        updateParkingList(filteredLots);
        // --- Fix: fetch and update route/distance for each filtered lot ---
        parking_list = [];
        if (userLocation) {
          filteredLots.forEach(point => {
            const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${userLocation[0]},${userLocation[1]};${point.lng},${point.lat}?geometries=geojson&access_token=${mapboxgl.accessToken}`;
            fetch(url)
              .then(res => res.json())
              .then(result => {
                if (result.routes && result.routes[0]) {
                  const distanceKm = (result.routes[0].distance / 1000).toFixed(2);
                  const durationMin = Math.round(result.routes[0].duration / 60);
                  const route = result.routes[0].geometry;
                  parking_list.push({
                    ...point,
                    distance: parseFloat(distanceKm),
                    duration: durationMin,
                    route: route
                  });
                }
              });
          });
        }
      });
  }

  // ä½¿ç”¨è€…å®šä½ï¼†è¨ˆç®—è·é›¢
  function locateUser() {
    navigator.geolocation.getCurrentPosition(position => {
      userLocation = [position.coords.longitude, position.coords.latitude];
      new mapboxgl.Marker({ color: '#3498db' })
        .setLngLat(userLocation)
        .setPopup(new mapboxgl.Popup().setText("ä½ çš„ä½ç½®"))
        .addTo(map);
      map.flyTo({ center: userLocation, zoom: 15 });

      // é å…ˆè¨ˆç®—æ‰€æœ‰åœè»Šå ´è·é›¢ä¸¦æ¸²æŸ“
      renderParkingLotsWithDistance(position.coords.latitude, position.coords.longitude);

      // å®šä½å®Œæ‰å»è¨ˆç®—æ‰€æœ‰è·é›¢ï¼ˆåŸæœ¬çš„é‚è¼¯ä¿ç•™ï¼‰
      parking_markers.forEach(item => {
        const point = item.data;
        const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${userLocation[0]},${userLocation[1]};${point.lng},${point.lat}?geometries=geojson&access_token=${mapboxgl.accessToken}`;

        fetch(url)
          .then(res => res.json())
          .then(result => {
            const distanceKm = (result.routes[0].distance / 1000).toFixed(2);
            const durationMin = Math.round(result.routes[0].duration / 60);
            const route = result.routes[0].geometry;

            parking_list.push({
              ...point,
              distance: parseFloat(distanceKm),
              duration: durationMin,
              route: route
            });
          });
      });
    }, () => {
      alert("ç„¡æ³•å–å¾—æ‚¨çš„å®šä½ï¼Œè«‹ç¢ºèªå®šä½æ¬Šé™ã€‚");
    });
  }

  // å¦‚æœä¸€é€²ä¾†å°±æœ‰å®šä½æ¬Šé™ï¼Œç›´æ¥æ¸²æŸ“
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(position => {
      renderParkingLotsWithDistance(position.coords.latitude, position.coords.longitude);
    });
  } else {
    // fallback: ä¸é¡¯ç¤ºä»»ä½•åœè»Šå ´
  }

  // Listen for checkbox change
  document.addEventListener('DOMContentLoaded', function() {
    const checkboxes = document.querySelectorAll('input[type="checkbox"]');
    const indoorCheckbox = checkboxes[0];
    const evCheckbox = checkboxes[1];
    // ç›£è½åƒ¹æ ¼ä¸Šé™ input
    const priceInput = document.getElementById('price-input');
    function updatePriceLimitAndRender() {
      const val = priceInput.value.trim();
      if (val === '') {
        priceUpperLimit = null;
      } else {
        const num = parseInt(val, 10);
        priceUpperLimit = isNaN(num) ? null : num;
      }
      if (userLocation) {
        renderParkingLotsWithDistance(userLocation[1], userLocation[0]);
      }
    }
    priceInput.addEventListener('change', updatePriceLimitAndRender);
    priceInput.addEventListener('keyup', function(e) {
      if (e.key === 'Enter') updatePriceLimitAndRender();
    });
    if (indoorCheckbox) {
      indoorCheckbox.addEventListener('change', function() {
        filterIndoor = this.checked;
        if (userLocation) {
          renderParkingLotsWithDistance(userLocation[1], userLocation[0]);
        }
      });
    }
    if (evCheckbox) {
      evCheckbox.addEventListener('change', function() {
        filterEV = this.checked;
        if (userLocation) {
          renderParkingLotsWithDistance(userLocation[1], userLocation[0]);
        }
      });
    }
  });

    document.addEventListener('DOMContentLoaded', function() {
      const menuBtn = document.getElementById('menu-toggle-btn');
      const sidenav = document.getElementById('filter-sidenav');
      let sidenavOpen = true;
      menuBtn.addEventListener('click', function() {
        if (sidenavOpen) {
          sidenav.style.left = '-320px'; // Hide the sidenav (slide out)
          sidenavOpen = false;
        } else {
          sidenav.style.left = '0'; // Show the sidenav (slide in)
          sidenavOpen = true;
        }
      });
    });

  document.addEventListener('DOMContentLoaded', function() {
    const rangeSelect = document.getElementById('range-select');
    const rangeInput = document.getElementById('range-input');
    const rangeSubmit = document.getElementById('range-submit-btn');
    function updateRangeAndRender() {
      rangeMode = rangeSelect.value;
      const val = parseInt(rangeInput.value, 10);
      if (rangeMode === 'count') {
        if (!isNaN(val) && val > 0) {
          MAX_PARKING_RENDER = val;
          rangeValue = null;
          if (userLocation) {
            renderParkingLotsWithDistance(userLocation[1], userLocation[0]);
          }
        } else {
          alert('è«‹è¼¸å…¥å¤§æ–¼0çš„æ•´æ•¸');
        }
      } else if (rangeMode === 'distance') {
        if (!isNaN(val) && val > 0) {
          rangeValue = val;
          if (userLocation) {
            renderParkingLotsWithDistance(userLocation[1], userLocation[0]);
          }
        } else {
          alert('è«‹è¼¸å…¥å¤§æ–¼0çš„æ•´æ•¸');
        }
      }
    }
    rangeSubmit.addEventListener('click', updateRangeAndRender);
    rangeSelect.addEventListener('change', updateRangeAndRender);
    rangeInput.addEventListener('keyup', function(e) {
      if (e.key === 'Enter') updateRangeAndRender();
    });
  });

  // é¡¯ç¤ºèšé¡åœ“åœˆåœˆèˆ‡è¦†è“‹è™•æ¨™è¨˜ç¸½æ•¸ï¼ˆåœ°åœ–ç¸®æ”¾å¤§å°æ”¹è®Šæ™‚ï¼‰
function showClusterCountCircle() {
  // å–å¾—æ‰€æœ‰èšé¡é» (clusters)
  const clusters = map.queryRenderedFeatures({ layers: ['clusters'] });
  let clusterBadge = document.getElementById('cluster-count-badge');
  if (clusters.length > 0) {
    // åªé¡¯ç¤ºæœ€å¤§ä¸€å€‹èšé¡ï¼ˆæˆ–å…¨éƒ¨èšé¡éƒ½é¡¯ç¤ºï¼‰
    if (!clusterBadge) {
      clusterBadge = document.createElement('div');
      clusterBadge.id = 'cluster-count-badge';
      clusterBadge.style.position = 'fixed';
      clusterBadge.style.right = '32px';
      clusterBadge.style.bottom = '100px';
      clusterBadge.style.zIndex = '999';
      document.body.appendChild(clusterBadge);
    }
    // åªé¡¯ç¤ºæœ€å¤§èšé¡çš„æ•¸é‡
    const maxCluster = clusters.reduce((a, b) => (a.properties.point_count > b.properties.point_count ? a : b));
    const count = maxCluster.properties.point_count;
    clusterBadge.innerHTML = `
      <div style="position:relative;display:flex;align-items:center;justify-content:center;">
        <svg width="56" height="56" viewBox="0 0 56 56">
          <circle cx="28" cy="28" r="24" fill="#e74c3c" stroke="#fff" stroke-width="4"/>
        </svg>
        <span style="position:absolute;left:0;top:0;width:56px;height:56px;display:flex;align-items:center;justify-content:center;font-size:22px;font-weight:bold;color:#fff;">${count}</span>
      </div>
    `;
    clusterBadge.style.display = 'block';
  } else {
    if (clusterBadge) clusterBadge.style.display = 'none';
  }
}

map.on('zoomend', showClusterCountCircle);
map.on('moveend', showClusterCountCircle);
map.on('load', showClusterCountCircle);

// åœ¨åœ°åœ–åŠ è¼‰å®Œæˆå¾Œï¼ŒåŠ å…¥ symbol/circle layer é¡¯ç¤ºå‰©é¤˜ç©ºä½ï¼ˆtotalcarï¼‰åœ¨ç¯€é»æ­£ä¸­å¤®
map.on('load', function() {
  // åŠ å…¥ symbol layer é¡¯ç¤ºå‰©é¤˜ç©ºä½
  if (map.getSource('parkings')) {
    // å·²æœ‰ source ä¸éœ€é‡è¤‡åŠ 
    return;
  }
  // å–å¾—æ‰€æœ‰åœè»Šå ´è³‡æ–™
  fetch('data/TCMSV_alldesc.json')
    .then(response => response.json())
    .then(json => {
      const features = json.data.park.map(point => ({
        type: 'Feature',
        properties: point,
        geometry: {
          type: 'Point',
          coordinates: [point.lng, point.lat]
        }
      }));
map.addSource('parkings', {
  type: 'geojson',
  data: {
    type: 'FeatureCollection',
    features: features
  },
  cluster: true,
  clusterRadius: 30,
  clusterMaxZoom: 18,
  clusterProperties: {
    cluster_totalcar: ['+', ['get', 'totalcar']]
  }
});
      // åœ“å½¢ç¯€é»ï¼ˆç´…è‰²ï¼Œåƒ…é¡¯ç¤ºæœªèšé¡é»ï¼‰
      map.addLayer({
        id: 'parking-circle',
        type: 'circle',
        source: 'parkings',
        filter: ['!', ['has', 'point_count']], // åªé¡¯ç¤ºæœªèšé¡é»
        paint: {
          'circle-color': '#e74c3c',
          'circle-radius': 18,
          'circle-stroke-width': 3,
          'circle-stroke-color': '#fff'
        }
      });
      // æ•¸å­—åœ¨ç´…è‰²åœ“å½¢æ­£ä¸­å¤®ï¼ˆåƒ…é¡¯ç¤ºæœªèšé¡é»ï¼‰
      map.addLayer({
        id: 'parking-count',
        type: 'symbol',
        source: 'parkings',
        filter: ['!', ['has', 'point_count']], // åªé¡¯ç¤ºæœªèšé¡é»
        layout: {
          'text-field': ['to-string', ['get', 'totalcar']],
          'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
          'text-size': 16,
          'text-anchor': 'center',
          'text-allow-overlap': true,
          'icon-allow-overlap': true
        },
        paint: {
          'text-color': '#fff',
          'text-halo-color': '#e74c3c',
          'text-halo-width': 2
        }
      });

      // æ–°å¢ï¼šzoom > 15 é¡¯ç¤ºåƒ¹æ ¼åœ¨åœˆåœˆé™„è¿‘
      map.addLayer({
        id: 'parking-price',
        type: 'symbol',
        source: 'parkings',
        filter: [
          'all',
          ['!', ['has', 'point_count']],
          ['>', ['zoom'], 15]
        ],
        layout: {
          'text-field': [
            'concat',
            '$',
            [
              'to-string',
              [
                'coalesce',
                ['get', 'price'],
                ''
              ]
            ]
          ],
          'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
          'text-size': 15,
          'text-anchor': 'top',
          'text-offset': [0, 2.2],
          'text-allow-overlap': true
        },
        paint: {
          'text-color': '#ffd700',
          'text-halo-color': '#222',
          'text-halo-width': 2
        }
      });

      // æ–°å¢ï¼šèšé¡åœˆåœˆï¼ˆè—è‰²ï¼‰é¡¯ç¤ºé‡ç–ŠåŠ ç¸½
      map.addSource('parking-clusters', {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: features
        },
        cluster: true,
        clusterRadius: 30,
        clusterMaxZoom: 18,
        clusterProperties: {
          cluster_totalcar: ['+', ['get', 'totalcar']]
        }
      });
      // è—è‰²èšé¡åœˆåœˆ
      map.addLayer({
        id: 'parking-cluster-circle',
        type: 'circle',
        source: 'parking-clusters',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': '#3498db',
          'circle-radius': 22,
          'circle-stroke-width': 3,
          'circle-stroke-color': '#fff'
        }
      });
      // èšé¡åŠ ç¸½æ•¸å­—ï¼ˆtotalcaråŠ ç¸½ï¼‰
      map.addLayer({
        id: 'parking-cluster-count',
        type: 'symbol',
        source: 'parking-clusters',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': [
            'to-string',
            ['get', 'cluster_totalcar']
          ],
          'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
          'text-size': 17,
          'text-anchor': 'center',
          'text-allow-overlap': true
        },
        paint: {
          'text-color': '#fff',
          'text-halo-color': '#3498db',
          'text-halo-width': 2
        }
      });

      // è¨ˆç®—æ¯å€‹èšé¡çš„ totalcar åŠ ç¸½ï¼ˆMapbox æ²’æœ‰åŸç”Ÿæ”¯æ´ï¼Œéœ€è‡ªè¨‚ clusterPropertiesï¼‰
      // éœ€åœ¨ addSource æ™‚åŠ ä¸Š clusterProperties
      // é‡æ–°å»ºç«‹ sourceï¼ŒåŠ å…¥ clusterProperties
      map.removeSource('parking-clusters');
      map.addSource('parking-clusters', {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: features
        },
        cluster: true,
        clusterRadius: 30,
        clusterMaxZoom: 18,
        clusterProperties: {
          cluster_totalcar: ['+', ['get', 'totalcar']]
        }
      });

      // é‡æ–°åŠ è—è‰²åœˆåœˆå’Œæ•¸å­—å±¤ï¼ˆé †åºä¸èƒ½è®Šï¼‰
      map.addLayer({
        id: 'parking-cluster-circle',
        type: 'circle',
        source: 'parking-clusters',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': '#3498db',
          'circle-radius': 22,
          'circle-stroke-width': 3,
          'circle-stroke-color': '#fff'
        }
      });
      map.addLayer({
        id: 'parking-cluster-count',
        type: 'symbol',
        source: 'parking-clusters',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': [
            'to-string',
            ['get', 'cluster_totalcar']
          ],
          'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
          'text-size': 17,
          'text-anchor': 'center',
          'text-allow-overlap': true
        },
        paint: {
          'text-color': '#fff',
          'text-halo-color': '#3498db',
          'text-halo-width': 2
        }
      });
    });
});

// åœ°åœ–å³ä¸‹è§’é¡¯ç¤º zoom å¤§å°
document.addEventListener('DOMContentLoaded', function() {
  const zoomDisplay = document.getElementById('zoom-level-display');
  function updateZoomDisplay() {
    zoomDisplay.textContent = `Zoom: ${map.getZoom().toFixed(2)}`;
  }
  map.on('zoom', updateZoomDisplay);
  map.on('load', updateZoomDisplay);
  updateZoomDisplay();
});
    </script>
    <!-- i-modal.html èªªæ˜è¦–çª—æŒ‰éˆ•èˆ‡å…§å®¹ -->
    <button id="open-modal">é¡¯ç¤ºèªªæ˜</button>
    <div id="info-modal" class="modal">
      <div class="modal-content">
        <span class="close" id="close-modal">&times;</span>
        <p>åœ¨å°ç£ï¼Œ<span class="highlight">å°‹æ‰¾åœè»Šä½</span>ç¶“å¸¸æ˜¯ä¸€ä»¶æ—¢è€—æ™‚åˆä»¤äººå›°æ“¾çš„äº‹æƒ…ã€‚ç‚ºäº†è§£æ±ºé€™å€‹å•é¡Œï¼Œæˆ‘å€‘æå‡ºäº†ã€Œåœè»Šå ´æ¯”åƒ¹ç¶²ã€çš„æ¦‚å¿µï¼Œæ‰“é€ å‡ºä¸€å€‹èƒ½å¤ å³æ™‚æŸ¥è©¢ä¸¦æ¯”è¼ƒå„åœè»Šå ´è³‡è¨Šçš„ç¶²ç«™ã€‚</p>
        <p>æœ¬ç¶²ç«™çš„æ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€æ˜¯é€éåœ°åœ–ä»‹é¢ï¼ˆæ¡ç”¨ <a href="https://www.mapbox.com/" target="_blank">Mapbox</a>ï¼‰æ¸…æ¥šå‘ˆç¾æ¯å€‹åœè»Šå ´çš„ä½ç½®ã€‚ä½¿ç”¨è€…å¯ä»¥æŸ¥è©¢ç›®å‰ä½ç½®åˆ°å„åœè»Šå ´çš„è·é›¢ï¼ˆé€éå¤–éƒ¨ API è¨ˆç®—ï¼‰ï¼Œä¸¦æ ¹æ“š <span class="highlight">åœè»Šè²»ç”¨ã€è·é›¢ã€å‰©é¤˜ç©ºä½</span>ç­‰æ¢ä»¶é€²è¡Œæ’åºï¼Œå¿«é€Ÿæ‰¾åˆ°æœ€åˆé©çš„åœè»Šå ´ã€‚</p>
        <p>ç¶²ç«™ä¹Ÿæä¾›å³æ™‚ç·šä¸Šç€è¦½é‡é¡¯ç¤ºï¼Œä»¥åˆ†æä½¿ç”¨è€…ä½¿ç”¨è¶¨å‹¢ï¼Œä¸¦åˆ©ç”¨æ¨¡æ“¬è³‡æ–™ä¾†å‘ˆç¾åœè»Šå ´è©³ç´°è³‡è¨Šã€‚</p>
        <p>é€²ä¸€æ­¥åŠŸèƒ½åŒ…æ‹¬é¡¯ç¤ºå„åœè»Šå ´æ”¯æ´çš„<span class="highlight">ä»˜æ¬¾æ–¹å¼</span>ï¼ˆå¦‚è¡Œå‹•æ”¯ä»˜ã€ä¿¡ç”¨å¡ç­‰ï¼‰ä»¥åŠæ˜¯å¦å…·å‚™<span class="highlight">é›»å‹•è»Šå……é›»è¨­å‚™</span>ï¼Œå¤§å¹…æå‡å¯¦ç”¨æ€§èˆ‡å®Œæ•´æ€§ã€‚</p>
        <p>é€éé€™æ¨£çš„è¨­è¨ˆï¼Œæˆ‘å€‘å¸Œæœ›ç‚ºå°ç£çš„é§•é§›äººæ‰“é€ ä¸€å€‹<span class="highlight">å¿«é€Ÿã€æ–¹ä¾¿ã€è³‡è¨Šé€æ˜</span>çš„åœè»Šå ´æŸ¥è©¢èˆ‡æ¯”åƒ¹å¹³å°ã€‚</p>
      </div>
    </div>
    <script>
    // i-modal.html modal script
    document.addEventListener('DOMContentLoaded', function() {
      const modal = document.getElementById("info-modal");
      const btn = document.getElementById("open-modal");
      const span = document.getElementById("close-modal");
      btn.onclick = function() {
        modal.style.display = "block";
      }
      span.onclick = function() {
        modal.style.display = "none";
      }
      window.addEventListener('click', function(event) {
        if (event.target == modal) {
          modal.style.display = "none";
        }
      });
    });
    </script>
</body>
</html>